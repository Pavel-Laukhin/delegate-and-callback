import UIKit

// Создаем класс официанта
class Waiter {
    
    /// Свойство "заказ" - опциональная информация о текущем заказе. О заказе может узнать только официант, поэтому "private".
    private var order: String?
    
    /// Метод "принять заказ".
    func takeOrder(_ food: String) {
        print("What would you like?")
        print("Yes, of cource!")
        order = food
        sendOrderToCook()
    }
    
    /// Метод "отправить заказ повару". Мог бы сделать только официант. Но как?
    private func sendOrderToCook() {
        // ??? Как передать повару заказ?
    }
    
    /// Метод "доставить блюдо клиенту". Умеет только официант.
    private func serveFood() {
        print("Your \(order!). Enjoy your meal!")
    }
    
}

// Создаем класс повара
class Cook {
    
    /// Свойство "сковорода". Есть только у повара.
    private let pan: Int = 1
    
    /// Свойство "плита". Есть только у повара.
    private let stove: Int = 1
    
    /// Метод "приготовить". Умеет только повар.
    private func cookFood(_ food: String) -> Bool {
        print("Let's take a pan")
        print("Let's put \(food) on the pan")
        print("Let's put the pan on the stove")
        print("Wait a few minutes")
        print("\(food) is ready!")
        return true
    }
    
}

// Нанимаем на работу официанта и повара (создаем экземпляры):
let waiter = Waiter()
let cook = Cook()


// Сначала скажем официанту получить заказ. Допустим, он получает курицу:
waiter.takeOrder("Chiken")

// Как теперь официанту передать повару, что ему приготовить?
// Конечно, можно было бы сделать так, если бы свойства и методы официанта и повара не были private. Но так как они private, то это не сработает:
cook.cookFood(waiter.order!)
// 'cookFood' is inaccessible due to 'private' protection level
// 'order' is inaccessible due to 'private' protection level

// И к тому же мы использовали некий сторонний код снаружи классов официанта и повара, которому необходимо иметь доступ к private свойствам и методам этих классов. А как официанту передать "изнутри" себя, используя встроенные свойства и методы своего класса? Тот же вопрос со стороны повара: "Как ему приготовить то, что известно только официанту, используя свойства и методы своего класса?"

// Тут на помощь приходит "лифт". В этот лифт официант кладет записку с заказом. А повар берет записку из лифта и ставит в лифт готовое блюдо для передачи повару. Такой "лифт" реализуется через протокол "Взаимообмен через лифт":
protocol InterchangeViaElevatorProtokol {
    func cookOrder(order: String) -> Bool
}

// В данном случае мы говорим, что у лифта есть "интерфейс", который должен быть понятен и официанту, и повару. Правила взаимообмена должны знать и официант, и повар. Официант кладет записку, а повар готовит по ней.
// Теперь давайте поправим классы, чтобы официант мог общаться с поваром через этот лифт. Научим их работать по этому правилу из протокола.

// Подпишем класс повара под протокол лифта. Грубо говоря, мы научим всех наших поваров соблюдать правила, описанные в этом протоколе "Обмен через лифт". В таком случае Xcode заставит нас дописать в класс повара метод из протокола. Этот метод в данном примере должен будет вернуть Bool значение. В этом методе мы вызовем ранее созданный метод cookFood.
extension Cook: InterchangeViaElevatorProtokol {
    func cookOrder(order: String) -> Bool {
        cookFood(order)
    }
}

// Далее официанту добавим свойство "получатель заказа через лифт". Официант знает, что этот получатель знает правила и приготовит то, что в записке.
extension Waiter {
    var receiverOfOrderViaElevator: InterchangeViaElevatorProtokol? { return cook }
}

// В данном примере мы использовали расширение, которое не позволяет делать переменные с хранимыми свойствами. Поэтому мы вынуждены дописать в фигурных скобках return cook.
// Но можно сделать по-другому: просто добавить без расширения прямо внутрь класса официанта это опциональное свойство, а затем извне присвоить этому свойству нашего повара. Главное не забыть подписать класс повара под протокол. Давайте так и сделаем. Удалим эти экстешнены и просто добавим строчки в ранее созданные классы.
// Вот теперь как будут выглядеть наши классы:
